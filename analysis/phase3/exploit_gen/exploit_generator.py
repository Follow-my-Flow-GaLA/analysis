import sys

external_scripts_path = '/media/datak/inactive/external/persistent-clientside-xss/src'
sys.path.append(external_scripts_path)
sys.path.append("/media/datak/inactive/analysis/phase3/exploit_gen")

from generator import generate_exploit_for_finding
from llm_exploit_gen import LLMExploitGenerator
from constants.sinks import SINKS

class ExploitGenerator():
    def __init__(self):
        self.finding_id = 1
        self.SINK_DICT = {
            "javascript": SINKS.SINK_EXEC, 
            "html": SINKS.SINK_INNER_HTML, 
            "scriptSrcSink": SINKS.SINK_SCRIPT_SRC
        }
    
    def prepare_input_formats(self, sink_dict):
        finding = {
            "finding_id": self.finding_id, 
            "sink_id": self.SINK_DICT[sink_dict["sink_type"]], 
            "sources": [
                {
                    "finding_id": self.finding_id,
                    "end": sink_dict["end_pos"],
                    "hasEncodingURI": 0,
                    "source": 8,
                    "hasEscaping": 0,
                    "start": sink_dict["start_pos"],
                    "value_part": sink_dict["sink_payload"],
                    "source_name": "inactive",
                    "hasEncodingURIComponent": 0,
                    "id": sink_dict["message_id"]
                }
            ], 
            "url": sink_dict["site"], 
            "storage": {
                "cookies": [ # "cookies" is just a fake source name; source is "inactive"
                    [
                        sink_dict["var_name"], # was source_var_name
                        sink_dict["src_payload"], # was source 
                        -1
                    ]
                ], 
                "storage": []
            }, 
            "value": sink_dict["sink_string"], 
            "d2": "",
            "d3": sink_dict["file_name"],
            "d1": sink_dict["sink_type"]
        }
        return finding
    
    def process(self, sink_dict, using_buffer=False, js_cache_only=False):
        # input format: 
        # sink_dict = {site: [{var_name, row_col(array), src_payload, file_name, 
        #              sink_payload, sink_type, start_pos, end_pos, sink_string}]
        
        if not using_buffer:
            # Prepare the data for use of javascript/non-js sinks
            js_codes, non_js_sink = {}, {}
            for site, info_list in sink_dict.items():
                js_codes[site] = []
                non_js_sink[site] = []
                for each_dict in info_list:
                    if each_dict["sink_type"] == "javascript":
                        code = each_dict["sink_string"][:each_dict["start_pos"]] + "MyString"
                        js_codes[site].append({**each_dict, **{'code':code,'site':site}})
                    elif each_dict["sink_type"] in ["html", "scriptSrcSink"]:
                        non_js_sink[site].append({**each_dict, **{'site':site}})
        else:
            from data_buffer import js_codes, non_js_sink
            sink_dict = {**js_codes, **non_js_sink}
                    
        # using llm_exploit_gen for javascript sinks
        eg = LLMExploitGenerator()
        if js_cache_only:
            js_ans = eg.batch_gen_cache_only(js_codes)
            # For non-cached, using rule-based 'generate_exploit_for_finding' to generate
            non_js_sink = {**js_codes, **non_js_sink}
        else:
            print('Using LLM for JS gen ... ')
            js_ans = eg.batch_gen(js_codes)
        
        # using traditional gen for non-js sinks
        for site, info_list in non_js_sink.items():
            for each_dict in info_list:
                if "exploit" in each_dict.keys():
                    continue
                if "site" not in each_dict.keys():
                    each_dict["site"] = site
                finding = self.prepare_input_formats(each_dict)
                # print(finding)
                # print(generate_exploit_for_finding(finding))
                result = generate_exploit_for_finding(finding)
                if result and type(result[0]) == dict and "replace_with" in result[0].keys():
                    each_dict["exploit"] = result[0]["replace_with"]
                else:
                    each_dict["exploit"] = "MyString"
                    
        print(f'--------js_ans---------\n{js_ans}\n--------non_js_sink---------\n{non_js_sink}')
        
        return_dict = {}
        for site in sink_dict.keys():
            return_dict[site] = []
            if site in js_ans.keys():
                for each_js_ans_dict in js_ans[site]:
                    if "exploit" in each_js_ans_dict.keys() and "MyString" not in each_js_ans_dict["exploit"]:
                        return_dict[site].append(each_js_ans_dict)
            if site in non_js_sink.keys():
                for each_non_js_sink_dict in non_js_sink[site]:
                    if "exploit" in each_non_js_sink_dict.keys() and "MyString" not in each_non_js_sink_dict["exploit"]:
                        # if containing "MyString", consider as unsuccessful exploit gen
                        return_dict[site].append(each_non_js_sink_dict)
        return_dict = {key:value for key,value in return_dict.items() if value}
        return return_dict
    
    
if __name__ == "__main__":
    eg = ExploitGenerator()
    print(eg.process({}, using_buffer=True))